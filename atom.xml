<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.wangjiechao.com</id>
    <title>寻寻觅觅</title>
    <updated>2022-05-25T03:20:34.483Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.wangjiechao.com"/>
    <link rel="self" href="https://www.wangjiechao.com/atom.xml"/>
    <logo>https://www.wangjiechao.com/images/avatar.png</logo>
    <icon>https://www.wangjiechao.com/favicon.ico</icon>
    <rights>All rights reserved 2022, 寻寻觅觅</rights>
    <entry>
        <title type="html"><![CDATA[眼科就医日记]]></title>
        <id>https://www.wangjiechao.com/post/eye-see-see/</id>
        <link href="https://www.wangjiechao.com/post/eye-see-see/">
        </link>
        <updated>2021-05-10T13:49:44.000Z</updated>
        <content type="html"><![CDATA[<p>最近半年眼睛都比较干燥，便在昨天便预约了成都市一医院的眼科吗，看下眼睛有什么隐疾</p>
<p>下午的号，按照公众号提示的时间赶到了，首先是量体温，使用电子健康码才能签到，签到后就可以等着叫号了，等了大约20分钟，终于轮到我了。</p>
<p>进去问了年龄多少，眼睛怎么了，答，眼睛最近下降严重，还经常干涩。 医生听了，直接让助手开了以下单子：<br>
<img src="https://www.wangjiechao.com/post-images/1620656343280.JPG" alt="" loading="lazy"></p>
<p>默默的去交了费，然后开始了漫长的检查之旅：</p>
<p>1.我先排了彩色打印照片和光学断层成像（OCT成像），然后去排了验光， <img src="https://www.wangjiechao.com/post-images/1620656554334.jpg" alt="检查单" loading="lazy"></p>
<p>排在了9号，这个项目排队预计15分钟一位，先做完 彩色打印照片，我前面有7个人，排了预计40分钟才排到我，赶快进去做了；之后会让你在外面等着喊你去另一个房间做OCT了，OCT我等了预计20分钟</p>
<p>通道非常狭窄，一大群人围在那里，老人居多，堵在门口，我也挤在哪里，默默等待着，中间还和群友调侃一番。<br>
<img src="https://www.wangjiechao.com/post-images/1620657296546.jpg" alt="" loading="lazy"></p>
<p>2.做完彩色打印照片，我就跑去验光了，单纯等OCT很枯燥，中间可以把验光做了，事实证明，应该先去排验光，因为验光一个人大约5分钟，而我排到了35号，前面十几个人，这就很难受。<br>
<img src="https://www.wangjiechao.com/post-images/1620657073263.jpg" alt="验光结果" loading="lazy">。<br>
验光过程就跟我们在眼镜店一样，但医生明显更加严谨；</p>
<p>3.之后就是OCT了，眼睛就盯着一个圆球，然后估计是机器在不停的扫描，打出来的就是如下的扫描图<br>
<img src="https://www.wangjiechao.com/post-images/1620657373560.JPG" alt="" loading="lazy"></p>
<p>咱也看不懂，就拿去给医生看</p>
<p>👩‍⚕️说没什么问题，注意休息，给开了眼药水，我看了下京东上的售价，果断买了海露。</p>
<p>要注意用眼了！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[眼科就医日记]]></title>
        <id>https://www.wangjiechao.com/post/yan-ke-jiu-yi-ri-ji/</id>
        <link href="https://www.wangjiechao.com/post/yan-ke-jiu-yi-ri-ji/">
        </link>
        <updated>2021-05-10T13:49:44.000Z</updated>
        <content type="html"><![CDATA[<p>最近半年眼睛都比较干燥，便在昨天便预约了成都市一医院的眼科吗，看下眼睛有什么隐疾</p>
<p>下午的号，按照公众号提示的时间赶到了，首先是量体温，使用电子健康码才能签到，签到后就可以等着叫号了，等了大约20分钟，终于轮到我了。</p>
<p>进去问了年龄多少，眼睛怎么了，答，眼睛最近下降严重，还经常干涩。 医生听了，直接让助手开了以下单子：<br>
<img src="https://www.wangjiechao.com/post-images/1620656343280.JPG" alt="" loading="lazy"></p>
<p>默默的去交了费，然后开始了漫长的检查之旅：</p>
<p>1.我先排了彩色打印照片和光学断层成像（OCT成像），然后去排了验光， <img src="https://www.wangjiechao.com/post-images/1620656554334.jpg" alt="检查单" loading="lazy"></p>
<p>排在了9号，这个项目排队预计15分钟一位，先做完 彩色打印照片，我前面有7个人，排了预计40分钟才排到我，赶快进去做了；之后会让你在外面等着喊你去另一个房间做OCT了，OCT我等了预计20分钟</p>
<p>通道非常狭窄，一大群人围在那里，老人居多，堵在门口，我也挤在哪里，默默等待着，中间还和群友调侃一番。<br>
<img src="https://www.wangjiechao.com/post-images/1620657296546.jpg" alt="" loading="lazy"></p>
<p>2.做完彩色打印照片，我就跑去验光了，单纯等OCT很枯燥，中间可以把验光做了，事实证明，应该先去排验光，因为验光一个人大约5分钟，而我排到了35号，前面十几个人，这就很难受。<br>
<img src="https://www.wangjiechao.com/post-images/1620657073263.jpg" alt="验光结果" loading="lazy">。<br>
验光过程就跟我们在眼镜店一样，但医生明显更加严谨；</p>
<p>3.之后就是OCT了，眼睛就盯着一个圆球，然后估计是机器在不停的扫描，打出来的就是如下的扫描图<br>
<img src="https://www.wangjiechao.com/post-images/1620657373560.JPG" alt="" loading="lazy"></p>
<p>咱也看不懂，就拿去给医生看</p>
<p>👩‍⚕️说没什么问题，注意休息，给开了眼药水，我看了下京东上的售价，果断买了海露。</p>
<p>要注意用眼了！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[antd vue 使用 分享]]></title>
        <id>https://www.wangjiechao.com/post/antd-vue-shi-yong-fen-xiang/</id>
        <link href="https://www.wangjiechao.com/post/antd-vue-shi-yong-fen-xiang/">
        </link>
        <updated>2021-02-08T01:47:31.000Z</updated>
        <content type="html"><![CDATA[<p>1.表单验证:</p>
<pre><code class="language-javascript">      validateMobile(rule, value, callback) {
        if (!value || new RegExp(/^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\d{8}$/).test(value)) {
          callback();
        } else {
          callback(&quot;您的手机号码格式不正确!&quot;);
        }
      },
      validateIdCard(rule, value, callback) {
        if (!value || new RegExp(/(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/).test(value)) {
          callback();
        } else {
          callback(&quot;您的身份证号码格式不正确!&quot;);
        }
      },
      ```
然后验证规则中加上即可  ` officeTelephone: { rules: [{ required: true, message: '请输入办公室电话!' },**{validator: this.validateMobile}**] }, `


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker容器互联和端口映射]]></title>
        <id>https://www.wangjiechao.com/post/docker-rong-qi-hu-lian/</id>
        <link href="https://www.wangjiechao.com/post/docker-rong-qi-hu-lian/">
        </link>
        <updated>2021-01-25T03:51:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="两个容器之间如何互通呢">两个容器之间如何互通呢</h2>
<blockquote>
<p>docker官方已经不推荐使用<code>--link</code>进行网络连接了,建议使用<strong>自定义网络</strong>来实现容器互联.但是我们可以了解下</p>
</blockquote>
<h3 id="自定义网络">自定义网络</h3>
<p>创建网络的命令是 <code>docker network create</code>。</p>
<pre><code class="language-bash">$  docker network create -d bridge individual
</code></pre>
<p>通过 -d 选项我们可以为新的网络指定驱动的类型，其值可以是刚才我们所提及的 <strong>bridge</strong>、<strong>host</strong>、<strong>overlay</strong>、<strong>maclan</strong>、<strong>none</strong>，也可以是其他网络驱动插件所定义的类型。这里我们使用的是 <code>Bridge Driver </code>( 当我们不指定网络驱动时，Docker 也会默认采用 Bridge Driver 作为网络驱动 )。</p>
<p>通过 <code>docker network ls </code>或是 <code>docker network list </code> 可以查看 Docker 中已经存在的网络。</p>
<pre><code class="language-bash">$  docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
bc14eb1da66b        bridge              bridge              local
35c3ef1cc27d        individual          bridge              local
</code></pre>
<p>之后在我们创建容器时，可以通过<code>--network</code>来指定容器所加入的网络，一旦这个参数被指定，容器便不会默认加入到 bridge 这个网络中了 ( 但是仍然可以通过 --network bridge 让其加入 )。</p>
<pre><code>$ docker run -d --name mysql -e MYSQL_RANDOM_ROOT_PASSWORD=yes --network individual mysql:5.7
</code></pre>
<p>我们通过 docker inspect 观察一下此时的容器网络。</p>
<pre><code>$  docker inspect mysql
[
    {
## ......
        &quot;NetworkSettings&quot;: {
## ......
            &quot;Networks&quot;: {
                &quot;individual&quot;: {
                    &quot;IPAMConfig&quot;: null,
                    &quot;Links&quot;: null,
                     ## ......    
                }
            }
## ......
        }
## ......
    }
]
</code></pre>
<p>可以看到，容器所加入网络已经变成了 individual 这个网络了。</p>
<p>这时候我们通过 --link 让处于另外一个网络的容器连接到这个容器上，看看会发生什么样的效果。</p>
<pre><code>$ docker run -d --name webapp --link mysql --network bridge webapp:latest
docker: Error response from daemon: Cannot link to /mysql, as it does not belong to the default network.
ERRO[0000] error waiting for container: context canceled
</code></pre>
<p>可以看到容器并不能正常的启动，而 Docker 提醒我们两个容器处于不同的网络，之间是不能相互连接引用的。</p>
<p>我们来改变一下，让运行 Web 应用的容器加入到 individual 这个网络，就可以成功建立容器间的网络连接了。</p>
<pre><code>$ docker run -d --name webapp --link mysql --network individual webapp:latest
</code></pre>
<h3 id="使用link连接">使用link连接</h3>
<p>要让一个容器连接到另外一个容器，我们可以在容器通过 <code>docker create</code> 或 <code>docker run </code>创建时通过 <code>--link</code> 选项进行配置。</p>
<p>例如，这里我们创建一个 MySQL 容器，将运行我们 Web 应用的容器连接到这个 MySQL 容器上，打通两个容器间的网络，实现它们之间的网络互通。</p>
<pre><code class="language-bash"> $ docker run -d --name mysql -e MYSQL_RANDOM_ROOT_PASSWORD=yes mysql

$ docker run -d --name webapp --link mysql webapp:latest
</code></pre>
<p>容器间的网络已经打通，那么我们要如何在 Web 应用中连接到 MySQL 数据库呢？Docker 为容器间连接提供了一种非常友好的方式，我们只需要将容器的网络命名填入到连接地址中，就可以访问需要连接的容器了。</p>
<p>假设我们在 Web 应用中使用的是 JDBC 进行数据库连接的，我们可以这么填写连接。</p>
<pre><code>String url = &quot;jdbc:mysql://mysql:3306/webapp&quot;;
</code></pre>
<p>在这里，连接地址中的 mysql 就好似我们常见的域名解析，Docker 会将其指向 MySQL 容器的 IP 地址。</p>
<p>在docker里面我们不再需要关心mysql容器中的地址,映射的事情交给docker处理就好.</p>
<h3 id="expose-port">expose port</h3>
<p>我们需要对应的地址和端口去访问对应的服务,Docker 为容器网络增加了一套安全机制，只有容器自身允许的端口，才能被其他容器所访问。</p>
<p>我们首先查看下容器暴露了哪些端口</p>
<pre><code class="language-bash">$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                 NAMES
95507bc88082        mysql:5.7           &quot;docker-entrypoint.s…&quot;   17 seconds ago      Up 16 seconds       3306/tcp, 33060/tcp   mysql
</code></pre>
<p>可以看到mysql:5.7这个景象暴露了<code> 3306</code>和<code>33060</code>端口,使用TCP协议访问.</p>
<p>想要暴露其他的端口,使用<code>--expose</code>参数即可,比如我们想暴露 33061和33062端口:</p>
<pre><code class="language-bash">$  docker run -d --name mysql -e MYSQL_RANDOM_ROOT_PASSWORD=yes --expose 33061 --expose 33062 mysql:5.7
</code></pre>
<p>我们在通过<code>docker ps</code>看一下</p>
<pre><code>$  docker ps 
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES
3c4e645f21d7        mysql:5.7           &quot;docker-entrypoint.s…&quot;   4 seconds ago       Up 3 seconds        3306/tcp, 13306/tcp, 23306/tcp, 33060/tcp   mysql
</code></pre>
<p>可以看到docker容器已经将对应的端口暴露出来了,我们可以访问这个端口了.</p>
<blockquote>
<p>容器暴露了端口只是类似我们打开了容器的防火墙，具体能不能通过这个端口访问容器中的服务，还需要容器中的应用监听并处理来自这个端口的请求。</p>
</blockquote>
<h3 id="alias">alias</h3>
<p>链接的时候就把容器的名字写死了,就丧失了灵活性和可配置性,如果代码里面写死了另一个名称,这样更改起来就会比较麻烦,docker支持使用alias来让我们摆脱容器名称的限制:</p>
<pre><code class="language-bash">docker run -d --name webapp --link mysql:database webapp:latest
</code></pre>
<p>我们使用 <code>--link &lt;name&gt;:&lt;alias&gt; </code>的形式把mysql容器的别名设置为database,<br>
上面的语句就可以写成</p>
<pre><code>String url = &quot;jdbc:mysql://database:3306/webapp&quot;;
</code></pre>
<h2 id="端口映射">端口映射</h2>
<p>容器和外部怎么进行连接呢,自然是端口映射</p>
<p>通过 Docker 端口映射功能，我们可以把容器的端口映射到宿主操作系统的端口上，当我们从外部访问宿主操作系统的端口时，数据请求就会自动发送给与之关联的容器端口。</p>
<p>要映射端口，我们可以在创建容器时使用 -p 或者是 --publish 选项。</p>
<pre><code>$ sudo docker run -d --name nginx -p 80:80 -p 443:443 nginx:1.12
</code></pre>
<p>使用端口映射选项的格式是<code> -p &lt;ip&gt;:&lt;host-port&gt;:&lt;container-port&gt;</code>，其中 ip 是宿主操作系统的监听 ip，可以用来控制监听的网卡，默认为 0.0.0.0，也就是监听所有网卡。host-port 和 container-port 分别表示映射到宿主操作系统的端口和容器的端口，这两者是可以不一样的，我们可以将容器的 80 端口映射到宿主操作系统的 8080 端口，传入 -p 8080:80 即可。</p>
<blockquote>
<p>容器的参数一般都是 宿主机(不好理解的话,就是操作系统)参数:容器参数.</p>
</blockquote>
<p>我们可以在容器列表里看到端口映射的配置。</p>
<pre><code>$ sudo docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                      NAMES
bc79fc5d42a6        nginx:1.12          &quot;nginx -g 'daemon of…&quot;   4 seconds ago       Up 2 seconds        0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp   nginx

</code></pre>
<p>打印的结果里用 -&gt; 标记了端口的映射关系。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jeecg-boot使用小tip]]></title>
        <id>https://www.wangjiechao.com/post/jeecg-boot-shi-yong-xiao-tip/</id>
        <link href="https://www.wangjiechao.com/post/jeecg-boot-shi-yong-xiao-tip/">
        </link>
        <updated>2020-03-18T08:27:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1查看详情界面不允许提交修改">1.查看详情界面不允许提交修改</h3>
<p><a-model> 组件 加上 <code>    :okButtonProps=&quot;{ props: {disabled: disableSubmit} }&quot;</code>属性,data中添加disableSubmit:false 即可</p>
<h3 id="2a-table-组件中文字溢出">2.a-table 组件中文字溢出</h3>
<p>在<code>&lt;a-table&gt;</code>增加</p>
<pre><code class="language-js">      &lt;span slot=&quot;ellipsis&quot; slot-scope=&quot;text, record&quot;&gt;
       &lt;j-ellipsis :value=&quot;text&quot;/&gt;
     &lt;/span&gt;     
</code></pre>
<p>将对应列增加以下属性</p>
<pre><code class="language-js">          width:200, 
          scopedSlots: { customRender: 'ellipsis' },
</code></pre>
<h3 id="3选择项目和人员如果自带的不满足需求可以使用jpopup进行开发">3.选择项目和人员如果自带的不满足需求可以使用jPopup进行开发.</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[es学习总结]]></title>
        <id>https://www.wangjiechao.com/post/es学习总结/</id>
        <link href="https://www.wangjiechao.com/post/es学习总结/">
        </link>
        <updated>2019-06-12T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="0️⃣安装">0️⃣.安装😀</h2>
<p>官网下载安装即可,注意学习时最好安装公司在用的版本型号.</p>
<h2 id="1️⃣基本概念">1️⃣.基本概念</h2>
<p>ES虽然是一个开源的分布式搜索引擎,但是你可以把它当做一个NoSQL的数据存储来使用.它是面向文档的,默认条件下是可扩展的.</p>
<h3 id="逻辑设计">逻辑设计</h3>
<h4 id="文档">文档</h4>
<p>ES中 搜索和存储的最小单位就是文档(document),毕竟ES中所存的数据很灵活,一般是JSON字符,个人认为完全可以把它当成&quot;文档&quot;;一篇文档同时包含字段和对应的值,而且文档中还可以包含新的文档;</p>
<p>ES中的文档不像SQL那样,具有严格的模式限制,ES中的文档是无模式的,也就数说并非所有的文档都需要拥有相同的字段,他们并不是受限于同一个模式.</p>
<p>虽然可以随意添加和忽略字段,但是每个字段的类型都很重要,毕竟字符串字段的类型你不能存储的时候存成整型类型,所以ES 中还有一个放置字段和字段类型映射的地方,和SQL中的表结构的概念相似,这种映射就叫做类型映射.</p>
<h4 id="类型">类型</h4>
<p>类型是文档的逻辑容器,类易于表示行的容器. 每个类型中字段的定义叫做映射.</p>
<p>映射包含某个类型中当前索引的所有文档的所有字段,但是并不是所有的文档必须要有所有的字段,</p>
<p>如果新近索引的文档又有一个映射中上不存在的字段,elasticsearch会自动的将新字段加入映射,加入的时候还会&quot;猜测&quot;这个字段是什么类型,假如值是7,es会猜测他是长整型.</p>
<p>​		<code>下了最新的ES学习时,发现ES的最新版本7.*之后已经不支持Type了,搜索时就只有一个_doc返回.</code></p>
<h4 id="索引">索引</h4>
<p>索引是映射类型的容器,作为存放大量文档集合的地方,类似于SQL中的数据库 .每个索引存储在硬盘上的同组文件中,</p>
<h3 id="逻辑设计-2">逻辑设计</h3>
<h4 id="节点">节点</h4>
<p>一个节点就是一个运行中的ES实例.在服务器上启动ES后,你就拥有了一个节点.如果在另一台服务器启动ES,那就是另一个节点.甚至可以通过启动多个进程(修改端口),在同一服务器上拥有多个节点.  多个节点可以同时加入同一个集群.对于使用ES的应用程序,集群中有一个还是多个节点都是透明的.默认情况下,可以连接集群中的任一节点并在这个节点中访问到集群中完整的数据集,就好像这个集群中就只有这一个节点.</p>
<h4 id="主分片和副本分片">主分片和副本分片</h4>
<p>一个主分片就是一个索引,每个主分片都会有一个副本分片.</p>
<h2 id="2️⃣索引更新和删除">2️⃣.索引,更新和删除</h2>
<h3 id="1索引数据">1.索引数据</h3>
<h4 id="11-核心的数据类型">1.1 核心的数据类型:</h4>
<figure data-type="image" tabindex="1"><img src="https://mywjch-1256164332.cos.ap-chengdu.myqcloud.com/%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%9E%8B_%E4%BF%AE%E6%94%B9.png" alt="数据类型" loading="lazy"></figure>
<h4 id="12-预定义字段">1.2 预定义字段</h4>
<p>预定义的字段都是很实用,而且会经常用到,这里罗列一下:</p>
<h5 id="如何存储和搜索你的文档">如何存储和搜索你的文档</h5>
<p>①存储原有内容的_source</p>
<p>​	_source字段会按照原有格式来存储原有的文档.   类似于你点击链接,进来这篇博文,看到了文章的所有信息.</p>
<p>②仅仅返回源文档的某些字段</p>
<p>​	可以在stored_fields参数中提供用逗号隔开的字段列表,比如</p>
<pre><code class="language-bash">curl -XGET get-together/group/1?stored_fields=name
</code></pre>
<p>③索引一切的_all</p>
<p>如果总是在特定的字段上搜索,可以通过设置enabled为false来关闭_all:</p>
<pre><code class="language-bash">&quot;events&quot;:{
	&quot;all&quot;:{&quot;enabled&quot;:false}
}
</code></pre>
<h5 id="识别文档">识别文档</h5>
<p>文档是通过_uid来唯一识别的,ES 内部使用 _uid 来唯一确定文档的身份.</p>
<p>_uid是由 _id和 _type组成,当搜索或者检索文档时总能获得这两项信息.</p>
<p>下面是这几个字段的相关信息:</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>是否存储</th>
<th>是否索引</th>
<th style="text-align:left">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>_uid</td>
<td>yes</td>
<td>yes</td>
<td style="text-align:left">用于识别整个索引中的某篇文档</td>
</tr>
<tr>
<td>_id</td>
<td>NO</td>
<td>NO</td>
<td style="text-align:left">该字段没有被索引,也没有被存储,如果搜索它,实际上使用的是_uid.当你获得了结果,同样是从 _uid中抽取内容</td>
</tr>
<tr>
<td>_type</td>
<td>NO</td>
<td>not_analyzed</td>
<td style="text-align:left">该字段是被索引的,并且也生成了单一的词条.ES用它来过滤指定类型的文档,也可以搜索这个字段.</td>
</tr>
</tbody>
</table>
<h3 id="2更新文档">2.更新文档</h3>
<p>可以参考此文章</p>
<p><a href="https://www.cnblogs.com/xing901022/p/5330778.html" class="LinkCard">Elasticsearch增删改查 之 —— Update更新</a></p>
<h3 id="3删除数据">3.删除数据</h3>
<p>①删除单个文档</p>
<p>发送HTTP <code>DELETE </code> 请求即可删除单一的文档:</p>
<pre><code class="language-bash">curl -XDELETE 'localhost:9200/online-shop/shirts/1'
</code></pre>
<p>为了 防止文档被删除后,也就不复存在了,但是一个更新操作机会重新创建该文档,尽管这是不允许发生的.毕竟我们希望这个数据永远的消失掉.为了避免这种问题,ES将会在一段时间内保留这篇文档的版本号,这样他就可以拒绝版本比删除操作更低的更新操作了.默认情况下这个时间是60秒.</p>
<p>②</p>
<p>③删除索引</p>
<p>就跟删除文档一样,删除索引需要下面的操作:</p>
<pre><code class="language-bash">curl -XDELETE 'localhost:9200/online-shop/'
</code></pre>
<p>通过提供以逗号隔开的列表,还可以删除多个索引.如果将索引名修改为<code>_all</code>,就可以删除掉所有的索引哦.</p>
<p>为了防止我们这样误操作,可以在elasticsearch.yml中的action.destructive_require_name:true 来预防这种情况对的发生,这会使ES在删除的时候拒绝_all参数,以及索引名称中的通配符.</p>
<p>删除索引是很快的,因为它基本上就是移除了和索引分片相关的文件.</p>
<p>④关闭索引</p>
<p>除了删除索引,还可以选择关闭索引.如果关闭了索引,就无法通过ES来读取和写入其中的数据,直到它再次打开.当使用应用日志这样的流式数据时,这样的操作非常实用.因为在现实世界中,应用日志最好永久的保存,以防要查看很久以前的信息,我们可能暂时不需要这些数据,但是也不想删除他它们.</p>
<p>为了关闭索引,我们可以这么做</p>
<pre><code class="language-bash">curl -XPOST 'localhost:9200/online-shop/_close'
</code></pre>
<p>打开的话,那就执行</p>
<pre><code class="language-bash">curl -XPOST 'localhost:9200/online-shop/_open'
</code></pre>
<h2 id="3️⃣搜索操作">3️⃣.搜索操作</h2>
<h2 id="4️⃣分析数据">4️⃣.分析数据</h2>
<h2 id="5️⃣遇到的错误">5️⃣遇到的错误</h2>
<ol>
<li>Kibana 启动出错: Your Kibana index is out of date, reset it or use the 💡-Pack upgrade assistant</li>
</ol>
<p>Deleting Kibana index worked for me (CAUTION: I had a brand new install),</p>
<p><code>curl -XDELETE http://localhost:9200/.kibana</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hadoop搭建和问题解决]]></title>
        <id>https://www.wangjiechao.com/post/hadoop搭建和问题解决/</id>
        <link href="https://www.wangjiechao.com/post/hadoop搭建和问题解决/">
        </link>
        <updated>2019-02-13T09:12:27.000Z</updated>
        <content type="html"><![CDATA[<p>1.参考<a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html">官方教程</a><br>
可以畅通无阻的部署好hadoop,如果是macos的话，也可以参考<a href="https://zhuanlan.zhihu.com/p/33117305">Mac OS 💡 上搭建 Hadoop 开发环境指南</a></p>
<p>2.提示 <strong>permission denied</strong> 的话应该考虑是ssh的问题,根据官方文档，可以通过</p>
<pre><code class="language-shell">  $ ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa
  $ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
  $ chmod 0600 ~/.ssh/authorized_keys
</code></pre>
<p>解决。<br>
如果已经新建好了id_rsa,直接执行后面两句就可以了。</p>
<p>3.开启dfs节点后,伪分布式(Pseudo-Distributed)下，我这里发现http://localhost:50070/ 访问不了，几次尝试和google,终于发现要在 <em>hdfs-site.xml</em> 种添加下面的属性:</p>
<pre><code class="language-xml">&lt;property&gt;
  &lt;name&gt;dfs.http.address&lt;/name&gt;
  &lt;value&gt;0.0.0.0:50070&lt;/value&gt;
&lt;/property&gt;
</code></pre>
<p>然后重新格式化namenode，启动hadoop，即可访问正常。</p>
<p>4.在往 <em>core-site.xml</em> 中添加下面的属性时，</p>
<pre><code class="language-xml">&lt;property&gt;
 &lt;name&gt;fs.defaultFS&lt;/name&gt;
 &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;
&lt;/property&gt;
</code></pre>
<p>可以将localhost修改为本机ip(macos 命令为 ifconfig),方便局域网其他设备查看。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git学习]]></title>
        <id>https://www.wangjiechao.com/post/git学习/</id>
        <link href="https://www.wangjiechao.com/post/git学习/">
        </link>
        <updated>2015-11-13T12:06:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念：</h1>
<h2 id="查看对象类型">查看对象类型</h2>
<p>git log --pretty=raw --graph e672332</p>
<p>打印提交对象之间的互相关联的跟踪链，--pragh显示parent属性，没有parent即为起点</p>
<h2 id="显示当前分支">显示当前分支</h2>
<p>git branch</p>
<h2 id="headmaster分支和refsheadsmaster区别">HEAD，master分支，和refs/heads/master区别</h2>
<p>使用master代表分支master中最新的提交，也可以使用全称refs/heads/master或heads/master</p>
<p>使用HEAD代表版本库中最近的一次提交</p>
<p>符号^可以用来只带父提交，如：</p>
<p>HEAD^代表版本库的上一次提交，即最近一次提交的父提交（即倒数第二次提交）</p>
<p>HEAD^<sup>代表HEAD</sup>的父提交</p>
<h2 id="git重置">Git重置</h2>
<p>git reset可以将游标指向任意一个存在的提交ID</p>
<p>git reset –hard HEAD^将master重置到上一个老的提交中，此时提交历史也会改变</p>
<p>使用git reset重置命令很危险，会彻底的丢失历史</p>
<p>使用Git reflog来挽回错误的重置</p>
<p>git reflog show master |head -5</p>
<p>7250a94 master@{0}: HEAD^: updating HEAD</p>
<p>df208c4 master@{1}: commit: leavewelcome.txt alone</p>
<p>7250a94 master@{2}: merge 7250a:Fast-forward</p>
<p>a2d0352 master@{3}: commit: 5th commit</p>
<p>67fba85 master@{4}: master@{3}: updatingHEAD</p>
<p>重置master为2次提交之前的值：</p>
<p>git reset –hard master@{2}</p>
<h2 id="git检出">git检出</h2>
<p>git branch -v查看当前分支</p>
<p>git chackout master切换到master分支上</p>
<p>git checkout branch检出branch分支</p>
<p>git merge ac23224将处于分离头指针状态的提交于当前分支合并</p>
<h1 id="基本操作">基本操作：</h1>
<h2 id="删除文件">删除文件：</h2>
<p>git rm ww.txt在版本库的最新提交中删除文件，在历史提交中还在。而直接在工作区删除文件，对暂存区和版本库没有任何影响。</p>
<h2 id="移动文件">移动文件:</h2>
<p>直接先使用linux的重命名：mv welcome.txt README</p>
<p>然后添加即可: git add  -A</p>
<h2 id="回复删除的文件">回复删除的文件：</h2>
<p>最简洁实用的语句:git checkout HEAD~1 --   welcome.txt</p>
<h2 id="选择性添加文件">选择性添加文件:</h2>
<p>git add -i使用交互式界面添加文件</p>
<h1 id="文件忽略">文件忽略：</h1>
<p>.gitignore的作用范围时其所出的目录及其子目录</p>
<p>Git的文件忽略只是对未入库(untrack)的文件起作用</p>
<p>Git的忽略语法:</p>
<p>1.忽略文件中的空行或以#开始的行会被忽略</p>
<p>2.可以使用通配符，*代表任意多字符，？代表单字符，[abc]代表可选字符范围</p>
<p>3.如果名称的最前面是一个路径分隔符(/)，表明要忽略的文件在此目录下，而非子目录的文件</p>
<p>4.如果名称的最后面是一个路径操作符(/),表明要忽略的是一整个目录，同名文件不忽略，否则（即没有/的话）同名的文件和目录都忽略。</p>
<p>5.在名称的最前面添加一个感叹号（！），代表不忽略</p>
<p>如：</p>
<p>*.a   #忽略所有以.a为扩展名的文件</p>
<p>!lib.a   #但是lib.a文件或目录不要忽略，即使是前面设置了对*.a的忽略</p>
<p>doc/*.txt  #忽略文件如doc/notes.txt ,但是文件如doc/serve/arch.txt不被忽略</p>
<p>/TODO  #只忽略此目录下的TODO文件，子目录的TODO文件不被忽略</p>
<p>build/   #忽略build/目录下所有的文件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你的知识需要管理-读书笔记]]></title>
        <id>https://www.wangjiechao.com/post/8/</id>
        <link href="https://www.wangjiechao.com/post/8/">
        </link>
        <updated>2015-08-23T05:34:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="第一节你的知识问题">第一节.你的知识问题</h3>
<p>开头的话深深的觉得说的很对</p>
<pre><code>“现在，所谓无知不是指没有知识，而是不会展示自己的知识、不会发挥知识的价值、
不会发现新知识、不会学习新知识，也不去创造知识。
对于主要靠知识谋生的知识工作者而言，你的知识管理过程是否运转自如，
是个人发展和个人竞争力能否持续提升的关键。”
</code></pre>
<p>然后开始一个标题一个标题的举起例子来:好单位靠不住,好老爸好老公靠不住(额,好老婆这么说也靠不住),'稳定'的职位也靠不住”,意思就是靠不住嘛,难道是要说只能靠自己?</p>
<p>果然,下面开始了:</p>
<h5 id="那我们依靠什么">(那)我们依靠什么</h5>
<p>“如果想拥有快乐的一生，你一定要靠自己：父母会老去、单位会破产、朋友会离开、夫妻可以化作分飞燕。如果想做一个有成就的人，你更要靠自己。”不靠自己真的会这样的哦.</p>
<p>“靠自己的劳动挣自己的饭吃并不丢人，丢人的是那些高水平工作做不了，低水平工作又不愿意做的“啃老族”。”恩,确实,赞同.</p>
<p>另外补充了一个观点:</p>
<p>“个人的发展主要靠自己，但并非拒绝别人的帮助，更不是不帮助别人。”</p>
<p>用好几十页文字进行了我们为什么要依靠自己的扯淡之后,终于说了一个很关键的地方:</p>
<h6 id="接下来的问题就是你应该靠自己什么">“接下来的问题就是：你应该靠自己什么？&quot;</h6>
<p>“现在每个人都必须要考虑自己如何快速学习知识、学习什么知识、如何保存掌握的知识、如何分享知识给你的合作伙伴、如何使用和创新知识。</p>
<p>简单地说，如果没有对整个知识过程的管理，那么你必然会丧失你的竞争力，无论你是高中毕业还是拥有博士学位。</p>
<h5 id="你的知识需要管理">你的知识需要管理</h5>
<p>主题出来了.</p>
<hr>
<h4 id="第二节-你的无知现状">“第二节　你的“无知”现状”</h4>
<p>又是一句大实话:</p>
<blockquote>
<p>“别以为你整天上互联网就有知识，你看的只不过是大量的信息而已！”</p>
</blockquote>
<p>因为现在互联网充斥着大量的信息,有用或无用,所以要这么做:</p>
<blockquote>
<p>“对于知识的爆炸，解决的方式是你要明确自己的知识需求。知识虽多但人生有限，<br>
如果知识不能被你所用，不能成为“你的知识”，这些知识对你也没有作用。”</p>
</blockquote>
<p>还有就是:</p>
<h3 id="别把数据-信息和知识相混淆">“别把数据、信息和知识相混淆”</h3>
<p>三者的区别见笔记图1(书中表1)</p>
<p>后面也把知识分为2类:</p>
<p>“知识又可以分为显性知识和隐性知识。所谓显性知识是指能够用语言、文字、肢体等方式表达清楚的知识；而隐性知识则是虽然知道如何做，但却很难告诉别人或者写明白、说明白的知识。从掌握知识的角度讲，大量的知识以隐性的成分存在着，而能显性化的部分较少。”</p>
<p>“隐性知识显性化应该成为现代人的一项必备能力，如果你不能显性化你的知识，就无法建立你的竞争力。为什么中医中药很难做大，一个很重要的原因是它们主要依靠隐性知识作判断，所以传承、复制的难度较大，因此就很难快速发展。</p>
<p>隐性知识还有一些特点，了解这些特点对于你管理自己的知识很有价值。</p>
<ul>
<li>
<p>你的隐性知识可能只是对你自己是隐性的，对于其他人、其他的机构可能已经是显性知识，这就需要你在前人基础上进行学习，明白是否已经有类似的显性知识；</p>
</li>
<li>
<p>隐性知识需要环境（此时、此地），并非永远是隐性的；</p>
</li>
<li>
<p>谁能将隐性的知识最先显性化，谁就是知识创新的开拓者。譬如许多大师的创新，多年后也有不同的人表达，但前者是”“大师，因为他最早将隐性知识显性化；</p>
</li>
<li>
<p>隐性知识显性化能力成为人与人之间能力差别的重要方面。将自己的隐性知识显性化应该成为每个知识工作者应具备的能力之一；</p>
</li>
<li>
<p>隐性知识显性化需要需求、环境等外力的作用，外力的拉动加上个人显性化的意愿，可以促进隐性知识显性化的过程；</p>
</li>
<li>
<p>社区是促进隐性知识显性化的环境；</p>
</li>
<li>
<p>隐性知识显性化的方法：讨论、回答提问、需求的压力、工作分解、流程分析等；</p>
</li>
<li>
<p>不能用通俗、简单的语言和文字表述知识，表明对该领域知识掌握得不够深入。”</p>
<pre><code>  有点多,但是感觉说的很多,所以没有抽取主干,直接贴过来.
</code></pre>
</li>
</ul>
<p>因此,顺应时代而生的我们这一代叫 <strong>知识生产者</strong></p>
<p>下面是解释:</p>
<p>“那些主要工作内容为处理信息和知识，并在工作中利用信息和知识的人，以区别于原来的产业工人。”--by 彼得 德鲁克 &lt;&lt;卓有成效的管理者&gt;&gt;</p>
<p>所以这么说来,我就是知识生产者,因为“你的竞争力的源泉和优势就是你处理信息和知识的能力与效率。”</p>
<p>即   “未来＝知识管理能力”</p>
<p>但是我们面对信息可能还会有诸多问题:</p>
<ul>
<li>“第一个问题是不知道如何评估信息，看到什么信息就相信什么信息，缺乏对信息评估的能力；</li>
<li>第二个问题是他们不知道有目标地去获取信息，因为缺乏知识基础，他们很难产生对信息的明确需求。”</li>
</ul>
<p>所以说:</p>
<blockquote>
<p>“知识与信息不同，知识除了要靠经验去消化汇集来的信息，还要去验证、思考，甚至在亲身体验过程中，去发现问题、解决问题。</p>
</blockquote>
<p>在当今时代下，个人的成长和发展以及个人竞争优势的建立，绝对不是靠信息的数量（虽然缺乏信息和获取信息的能力可以成为一个人发展的劣势）。不要以为你整天在互联网上就掌握了知识，互联网上的信息和知识你能获得我也能获得，互联网上有显性的知识也有信息，显性的知识必须跟你个人的原有知识结合起来，转化成你的隐性知识，加上对环境的判断才能发挥作用。”</p>
<p>接下来该总结第二节了:</p>
<blockquote>
<p>“人只能依靠自己，而依靠自己最重要的一点是依靠自己对个人知识过程的管理。只有对整个知识过程的管理才是现代人发展竞争力和竞争优势的源泉。”</p>
</blockquote>
<h4 id="第三节-你的五个知识问题">第三节 “你的五个知识问题”</h4>
<ul>
<li>“学习知识——你会学习吗”</li>
<li>“保存知识——用时能找到吗”</li>
<li>“知识共享——让人知道你知道”</li>
<li>“知识使用——能让知识带来价值吗”</li>
<li>“知识创新——能用创新超越竞争对手吗”</li>
</ul>
<p>重点的一些蛮实用的观点</p>
<p>“笔者反对无目的、无限制地存储大量的知识和信息，而要从个人发展的角度来分析自己的知识需求，建立个人知识存储的分类、命名规则，充分利用最新的技术手段协助自己对知识的保存和利用，让存储的知识真正对个人的学习、利用和创新产生价值，并提高整个知识管理过程的效率。”</p>
<p>“只有通过不断的知识共享、知识传播，才能让别人认识到你的价值和独特性，你才会被同事重视，被领导垂青，进而得到更多的机会”.“如果你想将你的知识共享或者传播的时候，你就会发现虽然你觉得自己知道，但这种知道是支离破碎、不系统的，你需要再学习和实践，这无形中促进了你对知识的掌握。”</p>
<p>“从知识保存的角度讲，人超不过图书馆和硬盘，所以知识的保存不是目的。我们掌握知识的目的在于让知识能够发挥作用，让知识帮助我们生活得更美好：改善我们的生活，提升生产效率和产品（服务）质量，赚更多的钱，职位更高，形成个人的影响力，心情更愉悦等。”</p>
<p>最后,作者给出了自己专业的观点:</p>
<blockquote>
<p>“笔者建议的原则是：</p>
<p>在你读书和工作的第一个十年，要更多地关注第一个问题（知识的学习）、第二个问题（知识的存储）、第三个问题（知识的共享和传播），因为在30岁以前，你可以更多地去探索自己的优势、特长来确定自己的学习目标和方向性，同时你要养成良好的知识保存习惯，乐于并善于分享，树立自己的专业形象；在这个阶段，因为相对来说对知识创新的要求不高，你尽可以做简单的知识使用方面的工作，在不同的企业进行体验。</p>
<p>在你工作的第二个十年，你需要更多地关注第三个问题（知识的共享和传播）、第四个问题（知识的利用）和第五个问题（知识的创新），通过知识的共享和传播建立自己在某个细分领域的专业形象，通过知识转化“转化为产品和服务直接提供给市场，通过知识创新引领一个领域的发展与进步。”</p>
</blockquote>
<blockquote>
<p>“当然，每个人的发展路径都不同，你需要自己去探索适合自己的路径。”</p>
</blockquote>
<h3 id="第二章-学习知识">“第二章  学习知识”</h3>
<p>开头痛快的骂了我一顿:</p>
<blockquote>
<p>“不学习当然不行，但学习也不一定行。你必须知道要学习什么知识，获取什么知识；同时，学习任何领域的知识必须达到一定的深度，否则你的知识就是常识。而常识怎么可能给你带来个人的竞争优势呢？”</p>
</blockquote>
<p>#你TM你的没有深度的知识就是TM的常识!!!!!!!!</p>
<p>我们继续</p>
<h5 id="第一节-为什么要学习">第一节 为什么要学习</h5>
<p>很多例子,废话,大家都懂的,略过</p>
<h5 id="第二节-学习什么知识">“第二节　学习什么知识”</h5>
<p><strong>“学习并不是最难的事情，而在学习中第一个问题就是学习什么。”</strong></p>
<p>说了两个误区:</p>
<ul>
<li>“只是爱上了学习本身，而没有考虑学什么，学习是为什么，如果学习没有方向性，以有限的时间和精力去追逐无限的知识内容，即使累死也没有效果。”--该学习什么</li>
<li>“在任何知识领域都浅尝辄止，欠缺知识的深度。”--学习的深度</li>
</ul>
<p>“知识工作者需要的基础知识是哪些？应该如何知道自己掌握了哪些知识呢？笔者提供一个简单的方法，你可以找一找每年国家公务员考试中基础知识部分的题目，自己做一下测试。它的内容覆盖了哲学、政治、经济、文化、法律、科学、数学、逻辑、阅读、表达等各个方面，通过做这种测试你可以发现自己最擅长和最差的领域，因此你可以有意识地去恶补一下自己最差的部分，因为这些知识是你跟人交流沟通、掌握信息、学习其他知识的基础，知识基础的不牢固会成为你个人成长和进步的一大障碍。”</p>
<h6 id="确定你的学习方向">“确定你的学习方向”</h6>
<p>“笔者可以告诉你的原则是：<br>
你的兴趣要远远大于你的能力和时间约束。所以你在确定自己的方向时，在你众多的兴趣中，你必须做减法：聚焦，首先你要在一个细分的领域达到专家的水平。这个聚焦越细越好。然后选择自己有兴趣又有优势的部分，经营自己的长处和优势。”</p>
<p>了解哦自我的方法和工具:<br>
1.你的价值观是什么<br>
2.你的个人目标是什么<br>
3.你的性格是什么--MBTI职业性格测试</p>
<h6 id="你应该学到什么程度">“你应该学到什么程度”</h6>
<p>“建议：了解你的优势，确定你的目标后，起码在一个领域的学习时间要达到3年以上，才能成为这个知识领域上的专家。”</p>
<h6 id="你的知识结构">“你的知识结构</h6>
<p>“除非把一件件事情放进构造好的模型里，否则很快就会忘记。详细的资料是靠表达它的简化方式来保存在记忆里的……获得的知识，<br>
如果没有完满的结构把它关联在一起，那是一种多半会被遗忘的知识。一串不连贯的论据在记忆中仅有短促得可怜的寿命。”<br>
——美国教育心理学家、哈佛大学“认知研究中心”创立者布鲁纳”</p>
<p>“知识更新的加速，要求人们要不断地学习新知识，调整原有的知识结构，建立起与时代发展相适应的知识结构。同时，还要使自己掌握的知识具有一定的超前性，根据时代发展需要，及时掌握和补充必备的知识，认准发展的趋势，站在发展的前列。</p>
<p>知识结构可分为3个主要层次：</p>
<ul>
<li>第一，基础层次，即我们上文提到的现代人的基础知识，它是知识工作者必备的基本文化素质和修养；</li>
<li>第二，中间层次，即较为系统的本专业知识，它是知识结构的特色，体现出不同知识工作者的特点和特色；</li>
<li>第三，最高层次，这一层次是知识工作者的优势所在，它包括你从事专业的最新成就、技术发展、方向和动态的知识。”</li>
</ul>
<p>“金字塔形知识结构又称“宝塔形知识结构”。其特点是宽阔的塔基（广博的基础知识）、较大的塔身（专业基础知识）、尖锐的塔尖（专业知识）。”</p>
<h5 id="第三节-怎样学习">“第三节　怎样学习”</h5>
<p>“人生短短数十载，时间是一个最稀缺的资源，而且是一个无法购买和复制的资源。所以在知识的学习中，你必须要考虑知识获取的“成本”问题，<br>
这个成本除了金钱之外，最重要的是时间成本。”</p>
]]></content>
    </entry>
</feed>